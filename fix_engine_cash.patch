diff --git a/portfolio_trades/engine.py b/portfolio_trades/engine.py
index 1111111..2222222 100644
--- a/portfolio_trades/engine.py
+++ b/portfolio_trades/engine.py
@@ -1,6 +1,7 @@
-import re import numpy as np import pandas as pd from .conventions import ( MAP_TO_SLEEVE, FALLBACK_PROXY, ACCOUNT_TAX_STATUS_RULES, DEFAULT_TAX_STATUS, EST_TAX_RATE, is_cashlike, is_automattic ) def assign_tax_status(acct: str) -> str: if not isinstance(acct, str): return DEFAULT_TAX_STATUS low = acct.lower() for pat, status in ACCOUNT_TAX_STATUS_RULES: if re.search(pat, low): return status return DEFAULT_TAX_STATUS def map_sleeve(sym: str, name: str) -> str: s = str(sym).upper().strip(); n = str(name).upper().strip() if is_automattic(s, n): return "Illiquid_Automattic" if s in MAP_TO_SLEEVE: return MAP_TO_SLEEVE[s] if "INFLATION" in n: return "TIPS" if any(k in n for k in ["UST","TREAS","STRIP"]): return "Treasuries" return "US_Core" def build_trades_and_afterholdings(h: pd.DataFrame, W: pd.Series, cash_tolerance: float = 100.0): """Compute trades (per account) to move toward portfolio-wide targets while: - prohibiting trades in Automattic - not transferring cash between accounts - minimizing sells (cap-gain aware: only sells incur realized gains) Inputs: h: DataFrame with columns Account, TaxStatus (optional), Name, Symbol, Quantity, Price (per share), AverageCost (per share), Value (=Quantity*Price), CostTotal (=Quantity*AverageCost) W: Series of target weights by Sleeve (portfolio-wide) Returns: tx: trades table after: holdings after trades (same schema as input plus Sleeve) residuals: dict of account -> residual cash flow (|flow| > tolerance reported) """ df = h.copy() if "TaxStatus" not in df.columns or df["TaxStatus"].eq("").all(): df["TaxStatus"] = df["Account"].map(assign_tax_status) # Sleeves df["Sleeve"] = [map_sleeve(s, n) for s, n in zip(df["Symbol"], df["Name"])] df["_ident"] = df["Symbol"].astype(str) # Canonical ident per (Account,Sleeve): largest $ in that account acct_sleeve_ident = ( df.groupby(["Account","Sleeve","_ident"])["Value"].sum() .reset_index().sort_values(["Account","Sleeve","Value"], ascending=[True,True,False]) .drop_duplicates(["Account","Sleeve"]) .set_index(["Account","Sleeve"])["_ident"].to_dict() ) # Global price map for any ident price_map = df.groupby("_ident")["Price"].median().to_dict() # Portfolio-total by account acct_tot = df.groupby("Account")["Value"].sum() trades = [] def round_shares(delta_dollars, px, ident): if px <= 0: return 0.0 return round(delta_dollars/px, 2) if is_cashlike(ident) else round(delta_dollars/px, 1) # For each account, compute target sleeve dollars from *portfolio-wide* W, # but remove Illiquid_Automattic from the investable pool inside that account.
+import re
+import numpy as np
+import pandas as pd
+from .conventions import (MAP_TO_SLEEVE, FALLBACK_PROXY, ACCOUNT_TAX_STATUS_RULES, DEFAULT_TAX_STATUS, EST_TAX_RATE, is_cashlike, is_automattic)
+
+def assign_tax_status(acct: str) -> str:
+    if not isinstance(acct, str): return DEFAULT_TAX_STATUS
+    low = acct.lower()
+    for pat, status in ACCOUNT_TAX_STATUS_RULES:
+        if re.search(pat, low): return status
+    return DEFAULT_TAX_STATUS
+
+def map_sleeve(sym: str, name: str) -> str:
+    s = str(sym).upper().strip(); n = str(name).upper().strip()
+    if is_automattic(s, n): return "Illiquid_Automattic"
+    if s in MAP_TO_SLEEVE:  return MAP_TO_SLEEVE[s]
+    if "INFLATION" in n:    return "TIPS"
+    if any(k in n for k in ["UST","TREAS","STRIP"]): return "Treasuries"
+    return "US_Core"
+
+def build_trades_and_afterholdings(h: pd.DataFrame, W: pd.Series, cash_tolerance: float = 100.0):
+    """
+    Compute trades (per account) to move toward the portfolio-wide sleeve targets.
+    Adds a per-account CASH trade to neutralize net dollars (within tolerance).
+    """
+    df = h.copy()
+    if "TaxStatus" not in df.columns or df["TaxStatus"].eq("").all():
+        df["TaxStatus"] = df["Account"].map(assign_tax_status)
+
+    df["Sleeve"] = [map_sleeve(s, n) for s, n in zip(df["Symbol"], df["Name"])]
+    df["_ident"] = df["Symbol"].astype(str)
+
+    acct_sleeve_ident = (
+        df.groupby(["Account","Sleeve","_ident"])["Value"].sum()
+          .reset_index()
+          .sort_values(["Account","Sleeve","Value"], ascending=[True,True,False])
+          .drop_duplicates(["Account","Sleeve"])
+          .set_index(["Account","Sleeve"])["_ident"].to_dict()
+    )
+
+    price_map = df.groupby("_ident")["Price"].median().to_dict()
+    acct_tot  = df.groupby("Account")["Value"].sum()
+
+    trades = []
+    def round_shares(delta_dollars, px, ident):
+        if px <= 0: return 0.0
+        return round(delta_dollars/px, 2) if is_cashlike(ident) else round(delta_dollars/px, 1)
+
+    # Sleeve target vs current per account
+    for acct, g in df.groupby("Account"):
+        total_val = float(acct_tot.get(acct, 0.0))
+        if total_val <= 0: continue
+
+        illq = g.loc[[is_automattic(s, n) for s,n in zip(g["Symbol"], g["Name"])], "Value"].sum()
+        investable = max(0.0, total_val - float(illq))
+
+        W_inv = W.copy()
+        if "Illiquid_Automattic" in W_inv.index:
+            W_inv = W_inv.drop(index="Illiquid_Automattic")
+        W_inv = W_inv / (W_inv.sum() if W_inv.sum() > 0 else 1.0)
+
+        tgt_val = (W_inv * investable)
+        cur_val = g.groupby("Sleeve")["Value"].sum()
+        all_sleeves = sorted(set(cur_val.index).union(tgt_val.index))
+        cur = cur_val.reindex(all_sleeves).fillna(0.0)
+        tgt = tgt_val.reindex(all_sleeves).fillna(0.0)
+        if "Illiquid_Automattic" in cur.index:
+            tgt.loc["Illiquid_Automattic"] = cur.loc["Illiquid_Automattic"]
+
+        delta_by_sleeve = (tgt - cur)
+        for sleeve, d_dollars in delta_by_sleeve.items():
+            if sleeve == "Illiquid_Automattic": continue
+            ident = acct_sleeve_ident.get((acct, sleeve)) or FALLBACK_PROXY.get(sleeve)
+            if not ident: continue
+            px = float(price_map.get(ident, 0.0))
+            if px <= 0: continue
+            if abs(d_dollars) < 1.0: continue
+
+            sh = round_shares(d_dollars, px, ident)
+            if sh == 0.0: continue
+
+            # Cap sells to held shares in THIS account
+            if d_dollars < 0:
+                held_sh = float(g.loc[g["_ident"] == ident, "Quantity"].sum())
+                sh = -min(abs(sh), abs(held_sh))
+                if sh == 0.0: continue
+
+            rows_ident = g[g["_ident"] == ident]
+            if not rows_ident.empty and rows_ident["Quantity"].sum() > 0:
+                tot_sh = float(rows_ident["Quantity"].sum())
+                avgc = float((rows_ident["AverageCost"] * rows_ident["Quantity"]).sum() / tot_sh)
+            else:
+                avgc = 0.0
+
+            action = "BUY" if sh > 0 else "SELL"
+            capgain = (px - avgc) * abs(sh) if action == "SELL" else 0.0
+            trades.append({
+                "Account": acct,
+                "TaxStatus": g["TaxStatus"].iloc[0],
+                "Identifier": ident,
+                "Sleeve": sleeve,
+                "Action": action,
+                "Shares_Delta": sh,
+                "Price": px,
+                "AverageCost": avgc,
+                "Delta_Dollars": sh * px,
+                "CapGain_Dollars": capgain,
+            })
+
+        # --- Add a CASH offset trade to neutralize net dollars in this account ---
+        acct_flow = sum(t["Delta_Dollars"] for t in trades if t["Account"] == acct)
+        if abs(acct_flow) > cash_tolerance:
+            cash_ident = acct_sleeve_ident.get((acct, "Cash")) or FALLBACK_PROXY.get("Cash", "BIL")
+            cash_px = float(price_map.get(cash_ident, 1.0)) or 1.0
+            sh_cash = round_shares(-acct_flow, cash_px, cash_ident)
+            if sh_cash != 0.0:
+                trades.append({
+                    "Account": acct,
+                    "TaxStatus": g["TaxStatus"].iloc[0],
+                    "Identifier": cash_ident,
+                    "Sleeve": "Cash",
+                    "Action": "BUY" if sh_cash > 0 else "SELL",
+                    "Shares_Delta": sh_cash,
+                    "Price": cash_px,
+                    "AverageCost": 0.0,
+                    "Delta_Dollars": sh_cash * cash_px,
+                    "CapGain_Dollars": 0.0,
+                })
+
+    tx = pd.DataFrame(trades)
+    if tx.empty:
+        after = df.copy()
+        return tx, after, {}
+
+    # Aggregate per (Account, Identifier)
+    agg = (
+        tx.groupby(["Account","Identifier","TaxStatus","Sleeve"], as_index=False)
+          .agg(
+              Shares_Delta=("Shares_Delta","sum"),
+              Price=("Price","last"),
+              AverageCost=("AverageCost","last"),
+              Delta_Dollars=("Delta_Dollars","sum"),
+              CapGain_Dollars=("CapGain_Dollars","sum"),
+          )
+    )
+    agg["Action"] = np.where(agg["Shares_Delta"] >= 0, "BUY", "SELL")
+    tx = agg.copy()
+
+    # Apply share deltas to holdings
+    after = df.copy()
+    after["_key"] = after["Account"].astype(str) + "||" + after["Symbol"].astype(str)
+    share_deltas = (
+        tx.assign(_key = tx["Account"].astype(str) + "||" + tx["Identifier"].astype(str))
+          .groupby("_key")["Shares_Delta"].sum().to_dict()
+    )
+    need_keys = set(share_deltas.keys()) - set(after["_key"])
+    if need_keys:
+        inv_proxy = {v:k for k,v in FALLBACK_PROXY.items()}
+        add_rows = []
+        for k in need_keys:
+            acct, ident = k.split("||", 1)
+            sleeve_guess = inv_proxy.get(ident, "US_Core")
+            px = float(df.loc[df["Symbol"]==ident, "Price"].median())
+            if not np.isfinite(px) or px <= 0: px = 1.0
+            add_rows.append({
+                "Account": acct, "TaxStatus": assign_tax_status(acct),
+                "Name": ident, "Symbol": ident, "Sleeve": sleeve_guess,
+                "Quantity": 0.0, "Price": px, "AverageCost": 0.0,
+                "Value": 0.0, "CostTotal": 0.0, "_key": k
+            })
+        after = pd.concat([after, pd.DataFrame(add_rows)], ignore_index=True)
+
+    def _apply(group: pd.DataFrame) -> pd.DataFrame:
+        acct = group["Account"].iloc[0]
+        ident = group["Symbol"].iloc[0]
+        k = f"{acct}||{ident}"
+        sh = float(share_deltas.get(k, 0.0))
+        if sh == 0.0: return group
+        g = group.copy()
+        g.loc[:, "Quantity"]  = g["Quantity"] + sh
+        g.loc[:, "Value"]     = g["Quantity"] * g["Price"]
+        g.loc[:, "CostTotal"] = g["Quantity"] * g["AverageCost"]
+        return g
+
+    after = after.groupby(["Account","Symbol"], group_keys=False).apply(_apply)
+    after = after[after["Quantity"].abs() > 1e-9].copy()
+    after["Value"]     = after["Quantity"] * after["Price"]
+    after["CostTotal"] = after["Quantity"] * after["AverageCost"]
+
+    # Residuals (should be near zero now)
+    flow = tx.groupby("Account")["Delta_Dollars"].sum()
+    residuals = {acct: float(v) for acct, v in flow.items() if abs(v) > cash_tolerance}
+    return tx, after, residuals