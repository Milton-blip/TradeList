diff --git a/portfolio_trades/engine.py b/portfolio_trades/engine.py
index 8a5f8ad..bdb3f33 100644
--- a/portfolio_trades/engine.py
+++ b/portfolio_trades/engine.py
@@ -1,33 +1,47 @@
 from __future__ import annotations
 import re
 from typing import Dict, Tuple
 import numpy as np
 import pandas as pd

 from .conventions import (
     MAP_TO_SLEEVE,
     FALLBACK_PROXY,
     ACCOUNT_TAX_STATUS_RULES,
     DEFAULT_TAX_STATUS,
     EST_TAX_RATE,
     is_cashlike,
     is_automattic,
 )

 # -------------------------
 # Helpers
 # -------------------------
 def assign_tax_status(acct: str) -> str:
     if not isinstance(acct, str):
         return DEFAULT_TAX_STATUS
     low = acct.lower()
     for pat, status in ACCOUNT_TAX_STATUS_RULES:
         if re.search(pat, low):
             return status
     return DEFAULT_TAX_STATUS


 def map_sleeve(sym: str, name: str) -> str:
     s = str(sym).upper().strip()
     n = str(name).upper().strip()
     if is_automattic(s, n):
         return "Illiquid_Automattic"
     if s in MAP_TO_SLEEVE:
         return MAP_TO_SLEEVE[s]
     if "INFLATION" in n:
         return "TIPS"
     if any(k in n for k in ["UST", "TREAS", "STRIP"]):
         return "Treasuries"
     return "US_Core"


 def _round_shares(dollars: float, px: float, ident: str) -> float:
     if px <= 0:
         return 0.0
     return round(dollars / px, 2) if is_cashlike(ident) else round(dollars / px, 1)

+def _tax_rate(status: str) -> float:
+    s = (status or "").lower()
+    if "hsa" in s or "roth" in s:
+        return 0.0
+    if "trust" in s:
+        return EST_TAX_RATE.get("Trust", 0.20)
+    if "taxable" in s:
+        return EST_TAX_RATE.get("Taxable", 0.15)
+    # default
+    return EST_TAX_RATE.get("Taxable", 0.15)
+

 # -------------------------
 # Core engine
 # -------------------------
 def build_trades_and_afterholdings(
     h: pd.DataFrame,
     W: pd.Series,
     cash_tolerance: float = 100.0,
 ):
@@ -43,196 +57,328 @@ def build_trades_and_afterholdings(
       Value (=Quantity*Price), Cost (=Quantity*AverageCost)
     """
     df = h.copy()

     # Ensure TaxStatus
     if "TaxStatus" not in df.columns or df["TaxStatus"].eq("").all():
         df["TaxStatus"] = df["Account"].map(assign_tax_status)

     # Sleeves and identifiers
     df["Sleeve"] = [map_sleeve(s, n) for s, n in zip(df["Symbol"], df["Name"])]
     df["_ident"] = df["Symbol"].astype(str)

     # Canonical ident to trade **within each account & sleeve** (pick largest $ there)
     acct_sleeve_ident: Dict[Tuple[str, str], str] = (
         df.groupby(["Account", "Sleeve", "_ident"])["Value"]
         .sum()
         .reset_index()
         .sort_values(["Account", "Sleeve", "Value"], ascending=[True, True, False])
         .drop_duplicates(["Account", "Sleeve"])
         .set_index(["Account", "Sleeve"])["_ident"]
         .to_dict()
     )

     # Price per ident
     price_map = df.groupby("_ident")["Price"].median().to_dict()

-    # Total value per account (for sizing)
-    acct_total = df.groupby("Account")["Value"].sum()
+    # --- Freeze illiquid (Automattic) dollars by account; investable per account ---
+    df["Illiquid"] = [
+        is_automattic(s, n) for s, n in zip(df["Symbol"], df["Name"])
+    ]
+    illiq_by_acct = df.loc[df["Illiquid"]].groupby("Account")["Value"].sum().reindex(
+        df["Account"].unique(), fill_value=0.0
+    )
+    acct_total = df.groupby("Account")["Value"].sum()
+    investable_by_acct = (acct_total - illiq_by_acct).clip(lower=0.0)

-    trades = []
+    # --- Portfolio-wide targets (values) excluding illiquid sleeve target ---
+    W_inv = W.copy()
+    if "Illiquid_Automattic" in W_inv.index:
+        W_inv = W_inv.drop(index="Illiquid_Automattic")
+    W_inv = W_inv / (W_inv.sum() if W_inv.sum() > 0 else 1.0)
+
+    total_investable = float(investable_by_acct.sum())
+    tgt_portfolio_val = (W_inv * total_investable).reindex(W_inv.index).fillna(0.0)
+
+    # --- Current sleeve values by account (investable sleeves only) ---
+    cur_by_as = (
+        df.loc[~df["Illiquid"]]
+          .groupby(["Account", "Sleeve"])["Value"].sum()
+          .unstack(fill_value=0.0)
+    )
+    # Make sure we have all sleeves present
+    for s in W_inv.index:
+        if s not in cur_by_as.columns:
+            cur_by_as[s] = 0.0
+    cur_by_as = cur_by_as[W_inv.index]  # column order
+
+    # --- Sleeve totals now and how much we need to add/remove to hit portfolio target ---
+    cur_portfolio_val = cur_by_as.sum(axis=0)
+    sleeve_shortfall = (tgt_portfolio_val - cur_portfolio_val)  # + need to add; - need to reduce
+
+    # --- Build a tax-aware allocation x[a,s] such that:
+    #     (1) For each sleeve s:   sum_a x[a,s] = tgt_portfolio_val[s]
+    #     (2) For each account a:  sum_s x[a,s] = investable_by_acct[a]
+    #     (3) x[a,s] >= 0
+    #     We bias reductions to zero-tax first, then losses, then low gain-per-$×taxrate.
+    accounts = list(investable_by_acct.index)
+    sleeves  = list(W_inv.index)
+
+    # Start from current allocations and adjust toward targets
+    x = cur_by_as.copy().reindex(index=accounts, columns=sleeves, fill_value=0.0)
+
+    # Helper: per (a,s) tax-cost score for *selling one dollar* of this sleeve in this account
+    # score = tax_rate(a) * max(0, (price - avg_cost)/price)
+    # (approx proportional to gain per dollar sold)
+    # Build avg cost per (a, ident) then map to sleeve using the dominant ident we trade in this account/sleeve.
+    # If we can't find, assume zero tax cost for sell (conservative for keeping sells in low-cost spots).
+    avgc_per_ai = (
+        df.groupby(["Account", "_ident"])
+          .apply(lambda g: (g["AverageCost"] * g["Quantity"]).sum() / max(1e-9, g["Quantity"].sum()))
+          .rename("avgc")
+          .reset_index()
+    )
+    avgc_lookup = {(r["Account"], r["_ident"]): float(r["avgc"]) for _, r in avgc_per_ai.iterrows()}
+
+    sell_cost = pd.DataFrame(0.0, index=accounts, columns=sleeves)
+    for a in accounts:
+        tr = _tax_rate(df.loc[df["Account"] == a, "TaxStatus"].iloc[0] if (df["Account"] == a).any() else "Taxable")
+        for s in sleeves:
+            ident = acct_sleeve_ident.get((a, s))
+            if not ident:
+                sell_cost.loc[a, s] = 0.0 if tr == 0 else tr * 0.5  # neutral-ish
+                continue
+            px = float(price_map.get(ident, 0.0)) or 0.0
+            avgc = float(avgc_lookup.get((a, ident), 0.0))
+            gain_per_dollar = 0.0
+            if px > 0:
+                gain_per_share = max(0.0, px - avgc)
+                gain_per_dollar = (gain_per_share / px)  # $gain per $sold
+            sell_cost.loc[a, s] = tr * gain_per_dollar
+
+    # --- First pass per sleeve: adjust totals to meet tgt_portfolio_val with tax-aware priority ---
+    # Reduce sleeves with surplus; increase sleeves with deficit.
+    for s in sleeves:
+        surplus = float((x[s].sum() - tgt_portfolio_val[s]))  # + surplus to cut; - deficit to add
+        if abs(surplus) < 1e-6:
+            continue
+        if surplus > 0:
+            # Need to CUT this sleeve by `surplus` across accounts: choose lowest sell_cost first
+            alloc = x[s].copy()  # current dollars by account
+            order = sell_cost[s].sort_values(ascending=True).index.tolist()
+            remaining = surplus
+            for a in order:
+                can_cut = float(alloc.get(a, 0.0))
+                if can_cut <= 0:
+                    continue
+                cut = min(can_cut, remaining)
+                x.loc[a, s] = alloc[a] - cut
+                remaining -= cut
+                if remaining <= 1e-6:
+                    break
+        else:
+            # Need to ADD -surplus to reach target: prefer accounts NOT selected for expensive sells
+            need = -surplus
+            alloc = x[s].copy()
+            # Prefer zero-tax (cost==0), then low cost
+            order = sell_cost[s].sort_values(ascending=True).index.tolist()
+            remaining = need
+            for a in order:
+                # Room to add in account a is whatever keeps account total feasible;
+                # We'll enforce account totals in the next step, so add greedily here.
+                x.loc[a, s] = alloc[a] + remaining
+                remaining = 0.0
+                break  # add everything to cheapest spot for this sleeve
+
+    # --- Enforce per-account totals: sum_s x[a,s] must equal investable_by_acct[a]
+    # If account a currently totals sum_x, we scale or shift sleeves proportionally
+    # but still respect the sleeve totals we just enforced: we do a constrained rescale.
+    desired_acct = investable_by_acct.reindex(accounts).fillna(0.0)
+    sum_per_acct = x.sum(axis=1)
+    for a in accounts:
+        have = float(sum_per_acct.get(a, 0.0))
+        want = float(desired_acct.get(a, 0.0))
+        if have <= 0:
+            continue
+        if abs(have - want) / max(1.0, want) < 1e-8:
+            continue
+        # scale all sleeves in this account
+        scale = (want / have) if have > 0 else 1.0
+        x.loc[a, :] = x.loc[a, :] * scale
+
+    # --- Final sleeve totals may drift a hair; normalize columns to exact target totals ---
+    col_sum = x.sum(axis=0)
+    for s in sleeves:
+        have = float(col_sum.get(s, 0.0))
+        want = float(tgt_portfolio_val.get(s, 0.0))
+        if have <= 0:
+            continue
+        if abs(have - want) / max(1.0, want) < 1e-10:
+            continue
+        x.loc[:, s] = x.loc[:, s] * (want / have)
+
+    # --- Now we have x[a,s] (account targets) and y[a,s]=cur_by_as (current).
+    # Trades are delta[a,s] = x - y (dollars). Convert to shares per account/sleeve ident.
+    trades = []

-    # Target sizing is portfolio-wide; per-account invests only its investable pool
-    for acct, g in df.groupby("Account"):
-        total_val = float(acct_total.get(acct, 0.0))
-        if total_val <= 0:
-            continue
-
-        # Illiquid Automattic dollars in this account (held, not traded)
-        illq_val = g.loc[
-            [is_automattic(s, n) for s, n in zip(g["Symbol"], g["Name"])], "Value"
-        ].sum()
-
-        investable = max(0.0, total_val - float(illq_val))
-
-        # Remove illiquid from investable target weights
-        W_inv = W.copy()
-        if "Illiquid_Automattic" in W_inv.index:
-            W_inv = W_inv.drop(index="Illiquid_Automattic")
-        W_inv = W_inv / (W_inv.sum() if W_inv.sum() > 0 else 1.0)
-
-        tgt_val = W_inv * investable
-        cur_val = g.groupby("Sleeve")["Value"].sum()
-
-        sleeves = sorted(set(cur_val.index).union(tgt_val.index))
-        cur = cur_val.reindex(sleeves).fillna(0.0)
-        tgt = tgt_val.reindex(sleeves).fillna(0.0)
-
-        # Keep illiquid fixed
-        if "Illiquid_Automattic" in cur.index:
-            tgt.loc["Illiquid_Automattic"] = cur.loc["Illiquid_Automattic"]
-
-        # Sleeve deltas (dollars)
-        delta = (tgt - cur)
-
-        # Generate per-sleeve trades (excluding illiquid)
-        for sleeve, d_dollars in delta.items():
-            if sleeve == "Illiquid_Automattic":
-                continue
-            ident = acct_sleeve_ident.get((acct, sleeve))
-            if ident is None:
-                ident = FALLBACK_PROXY.get(sleeve)
-            if ident is None:
-                continue
-
-            px = float(price_map.get(ident, 0.0))
-            if not np.isfinite(px) or px <= 0:
-                continue
-
-            # Skip micro-noise
-            if abs(d_dollars) < 1.0:
-                continue
-
-            sh = _round_shares(d_dollars, px, ident)
-            if sh == 0.0:
-                continue
-
-            # SELLs cannot exceed shares in THIS account
-            if d_dollars < 0:
-                held_sh = float(g.loc[g["_ident"] == ident, "Quantity"].sum())
-                sh = -min(abs(sh), abs(held_sh))  # negative shares for sell
-                if sh == 0.0:
-                    continue
-
-            # Account-level weighted average cost per share for this ident
-            rows_ident = g[g["_ident"] == ident]
-            if not rows_ident.empty and rows_ident["Quantity"].sum() > 0:
-                tot_sh = float(rows_ident["Quantity"].sum())
-                avgc = float(
-                    (rows_ident["AverageCost"] * rows_ident["Quantity"]).sum() / tot_sh
-                )
-            else:
-                avgc = 0.0
-
-            action = "BUY" if sh > 0 else "SELL"
-            capgain = (px - avgc) * abs(sh) if action == "SELL" else 0.0
-
-            trades.append(
-                {
-                    "Account": acct,
-                    "TaxStatus": g["TaxStatus"].iloc[0],
-                    "Identifier": ident,
-                    "Sleeve": sleeve,
-                    "Action": action,
-                    "Shares_Delta": sh,
-                    "Price": px,           # per-share
-                    "AverageCost": avgc,   # per-share
-                    "Delta_Dollars": sh * px,
-                    "CapGain_Dollars": capgain,
-                }
-            )
-
-        # ---------- Per-account CASH balancing ----------
-        # Make net dollars == 0 within this account by offsetting in CASH
-        if trades:
-            acct_trades = [t for t in trades if t["Account"] == acct]
-            net_flow = sum(t["Delta_Dollars"] for t in acct_trades)
-            if abs(net_flow) > cash_tolerance:
-                cash_ident = acct_sleeve_ident.get((acct, "Cash")) or FALLBACK_PROXY.get("Cash", "BIL")
-                cash_px = float(price_map.get(cash_ident, 1.0))
-                if np.isfinite(cash_px) and cash_px > 0:
-                    sh_cash = _round_shares(-net_flow, cash_px, cash_ident)  # offset
-                    if sh_cash != 0.0:
-                        # Avg cost for cash is irrelevant for gains (no SELL capgain assumed)
-                        trades.append(
-                            {
-                                "Account": acct,
-                                "TaxStatus": g["TaxStatus"].iloc[0],
-                                "Identifier": cash_ident,
-                                "Sleeve": "Cash",
-                                "Action": "BUY" if sh_cash > 0 else "SELL",
-                                "Shares_Delta": sh_cash,
-                                "Price": cash_px,
-                                "AverageCost": 0.0,
-                                "Delta_Dollars": sh_cash * cash_px,
-                                "CapGain_Dollars": 0.0,
-                            }
-                        )
+    for a in accounts:
+        g = df[df["Account"] == a]
+        for s in sleeves:
+            d_dollars = float(x.loc[a, s] - cur_by_as.loc[a, s])
+            if abs(d_dollars) < 1.0:
+                continue
+            ident = acct_sleeve_ident.get((a, s)) or FALLBACK_PROXY.get(s)
+            if not ident:
+                continue
+            px = float(price_map.get(ident, 0.0))
+            if not np.isfinite(px) or px <= 0:
+                continue
+            sh = _round_shares(d_dollars, px, ident)
+            if sh == 0.0:
+                continue
+
+            # SELL cannot exceed shares held in this account
+            if sh < 0:
+                held_sh = float(g.loc[g["_ident"] == ident, "Quantity"].sum())
+                sh = -min(abs(sh), abs(held_sh))
+                if sh == 0.0:
+                    continue
+
+            rows_ident = g[g["_ident"] == ident]
+            if not rows_ident.empty and rows_ident["Quantity"].sum() > 0:
+                tot_sh = float(rows_ident["Quantity"].sum())
+                avgc = float(
+                    (rows_ident["AverageCost"] * rows_ident["Quantity"]).sum() / tot_sh
+                )
+            else:
+                avgc = 0.0
+
+            action = "BUY" if sh > 0 else "SELL"
+            capgain = (px - avgc) * abs(sh) if action == "SELL" else 0.0
+            trades.append(
+                {
+                    "Account": a,
+                    "TaxStatus": g["TaxStatus"].iloc[0],
+                    "Identifier": ident,
+                    "Sleeve": s,
+                    "Action": action,
+                    "Shares_Delta": sh,
+                    "Price": px,
+                    "AverageCost": avgc,
+                    "Delta_Dollars": sh * px,
+                    "CapGain_Dollars": capgain,
+                }
+            )

     tx = pd.DataFrame(trades)

-    # --- Ensure per-account cash balance neutrality by adding a cash adjustment trade ---
-    if not tx.empty:
-        # Sum dollars per account from the trades we just built
-        acct_flow = tx.groupby("Account")["Delta_Dollars"].sum()
-
-        # Build a quick price map and a helper to pick a cash ident per account
-        price_map = df.groupby("_ident")["Price"].median().to_dict()
-
-        def pick_cash_ident(acct_group: pd.DataFrame) -> str | None:
-            # Prefer an actual cash-like holding in this account; else fallback to BIL
-            ids = acct_group["_ident"].unique().tolist()
-            for ident in ids:
-                if is_cashlike(ident):
-                    return ident
-            return "BIL"  # fallback proxy
-
-        # For each account, add one balancing trade in cash
-        for acct, flow in acct_flow.items():
-            if abs(flow) < 0.01:
-                continue  # already balanced enough
-            g_acct = df[df["Account"] == acct]
-            cash_ident = pick_cash_ident(g_acct)
-            px = float(price_map.get(cash_ident, 1.0))
-            if not np.isfinite(px) or px <= 0:
-                px = 1.0  # safeguard
-
-            # If prior trades resulted in net positive dollars (flow > 0), we need to SELL cash (negative shares)
-            # If net negative dollars (flow < 0), we need to BUY cash (positive shares)
-            shares = round(flow / px, 2)  # allow cents precision for cash
-            action = "SELL" if shares > 0 else "BUY"
-            # SELL must be negative shares; BUY positive
-            if action == "SELL":
-                shares = -abs(shares)
-            else:
-                shares = abs(shares)
-
-            tx = pd.concat(
-                [
-                    tx,
-                    pd.DataFrame(
-                        [
-                            {
-                                "Account": acct,
-                                "TaxStatus": g_acct["TaxStatus"].iloc[
-                                    0] if "TaxStatus" in g_acct.columns else assign_tax_status(acct),
-                                "Identifier": cash_ident,
-                                "Sleeve": "Cash",
-                                "Action": action,
-                                "Shares_Delta": shares,
-                                "Price": px,  # per share
-                                "AverageCost": 0.0,  # cash assumed at par for gain math
-                                "Delta_Dollars": shares * px,
-                                "CapGain_Dollars": 0.0,  # cash assumed no cap gains
-                            }
-                        ]
-                    ),
-                ],
-                ignore_index=True,
-            )
+    # No cash-balance line needed: x was constructed with per-account totals → flows close to 0
+    # (We still report residuals if rounding leaves a few dollars.)

     # Re-aggregate after inserting cash adjustments (so that net $/account ≈ 0)
     if not tx.empty:
         tx["_key"] = tx["Account"].astype(str) + "||" + tx["Identifier"].astype(str)
         agg = (
             tx.groupby(["Account", "Identifier", "TaxStatus", "Sleeve"], as_index=False)
             .agg(
                 Shares_Delta=("Shares_Delta", "sum"),
                 Price=("Price", "last"),
                 AverageCost=("AverageCost", "last"),
                 Delta_Dollars=("Delta_Dollars", "sum"),
                 CapGain_Dollars=("CapGain_Dollars", "sum"),
                 Action=("Action", "last"),
             )
         )
         agg["Action"] = np.where(agg["Shares_Delta"] >= 0, "BUY", "SELL")
         tx = agg.copy()
     else:
         # Build a minimal after = input + sleeve and return early if no trades
         after = df.copy()
         return tx, after, {}

     if tx.empty:
         after = df.copy()
         return tx, after, {}

     # Aggregate per (Account, Identifier) after cash balancing
     agg = (
         tx.groupby(["Account", "Identifier", "TaxStatus", "Sleeve"], as_index=False)
         .agg(
             Shares_Delta=("Shares_Delta", "sum"),
             Price=("Price", "last"),
             AverageCost=("AverageCost", "last"),
             Delta_Dollars=("Delta_Dollars", "sum"),
             CapGain_Dollars=("CapGain_Dollars", "sum"),
         )
     )
     agg["Action"] = np.where(agg["Shares_Delta"] >= 0, "BUY", "SELL")
     tx = agg.copy()

     # ---------- Build holdings-after by applying share deltas ----------
     after = df.copy()
     after["_key"] = after["Account"].astype(str) + "||" + after["_ident"].astype(str)

     share_deltas = (
         tx.assign(_key=tx["Account"].astype(str) + "||" + tx["Identifier"].astype(str))
         .groupby("_key")["Shares_Delta"]
         .sum()
         .to_dict()
     )

     # Ensure any (Account, Identifier) traded but not held gets a placeholder row
     have_keys = set(after["_key"])
     need_keys = set(share_deltas.keys()) - have_keys
     if need_keys:
         inv_proxy = {v: k for k, v in FALLBACK_PROXY.items()}
         add_rows = []
         for k in need_keys:
             acct, ident = k.split("||", 1)
             sleeve_guess = inv_proxy.get(ident, "US_Core")
             px = float(df.loc[df["_ident"] == ident, "Price"].median())
             if not np.isfinite(px) or px <= 0:
                 px = 1.0
             add_rows.append(
                 {
                     "Account": acct,
                     "TaxStatus": assign_tax_status(acct),
                     "Name": ident,
                     "Symbol": ident,
                     "Sleeve": sleeve_guess,
                     "_ident": ident,
                     "Quantity": 0.0,
                     "Price": px,
                     "AverageCost": 0.0,
                     "Value": 0.0,
                     "Cost": 0.0,
                     "_key": k,
                 }
             )
         after = pd.concat([after, pd.DataFrame(add_rows)], ignore_index=True)

     def _apply(group: pd.DataFrame) -> pd.DataFrame:
         acct = group["Account"].iloc[0]
         ident = group["_ident"].iloc[0]
         k = f"{acct}||{ident}"
         sh = float(share_deltas.get(k, 0.0))
         if sh == 0.0:
             return group
         g = group.copy()
         g.loc[:, "Quantity"] = g["Quantity"] + sh
         g.loc[:, "Value"] = g["Quantity"] * g["Price"]
         g.loc[:, "Cost"] = g["Quantity"] * g["AverageCost"]
         return g

-    after = after.groupby(["Account", "_ident"], group_keys=False).apply(_apply)
+    after = after.groupby(["Account", "_ident"], group_keys=False).apply(_apply)
     after = after[after["Quantity"].abs() > 1e-9].copy()
     after["Value"] = after["Quantity"] * after["Price"]
     after["Cost"] = after["Quantity"] * after["AverageCost"]

-    # Residuals (should be ~0 now; report only if we couldn’t balance cash)
-    flow = tx.groupby("Account")["Delta_Dollars"].sum()
-    residuals = {acct: float(v) for acct, v in flow.items() if abs(v) > cash_tolerance}
+    # Residuals: should be near 0 because x respected per-account totals
+    flow = tx.groupby("Account")["Delta_Dollars"].sum()
+    residuals = {acct: float(v) for acct, v in flow.items() if abs(v) > cash_tolerance}

     # --- Tax summary per account & tax status ---
-    def tax_rate_for_status(status: str) -> float:
-        """
-        Return the estimated capital gains tax rate for a given tax status.
-        HSAs and Roth IRAs are tax-exempt (0%).
-        """
-        s = status.lower()
-        if "hsa" in s or "roth" in s:
-            return 0.0
-        if "taxable" in s:
-            return EST_TAX_RATE.get("Taxable", 0.15)
-        if "trust" in s:
-            return EST_TAX_RATE.get("Trust", 0.20)
-        # fallback
-        return 0.0
+    def tax_rate_for_status(status: str) -> float:
+        return _tax_rate(status)

     # compute tax per-account
     acc_sum = (
         tx.groupby(["Account", "TaxStatus"], as_index=False)
         .agg(
             Total_Buys=("Delta_Dollars", lambda x: x[x > 0].sum()),
             Total_Sells=("Delta_Dollars", lambda x: -x[x < 0].sum()),
             Net_CapGain=("CapGain_Dollars", "sum"),
         )
     )
     acc_sum["Est_TaxRate"] = acc_sum["TaxStatus"].apply(tax_rate_for_status)
     acc_sum["Est_Tax"] = acc_sum["Net_CapGain"] * acc_sum["Est_TaxRate"]

-    # by tax status summary
-    # --- Summaries ---
-    acc_sum = (
-        tx.groupby(["Account", "TaxStatus"], as_index=False)
-        .agg(
-            Total_Buys=("Total_Buys", "sum"),
-            Total_Sells=("Total_Sells", "sum"),
-            Net_CapGain=("Net_CapGain", "sum"),
-            Est_Tax=("Est_Tax", "sum"),
-        )
-    )
-
-    by_status = (
-        acc_sum.groupby("TaxStatus", as_index=False)
-        .agg(
-            Total_Buys=("Total_Buys", "sum"),
-            Total_Sells=("Total_Sells", "sum"),
-            Net_CapGain=("Net_CapGain", "sum"),
-            Est_Tax=("Est_Tax", "sum"),
-        )
-    )
+    by_status = (
+        acc_sum.groupby("TaxStatus", as_index=False)
+        .agg(
+            Total_Buys=("Total_Buys", "sum"),
+            Total_Sells=("Total_Sells", "sum"),
+            Net_CapGain=("Net_CapGain", "sum"),
+            Est_Tax=("Est_Tax", "sum"),
+        )
+    )

     # Return full results
-    return tx, after, residuals
+    return tx, after, residuals